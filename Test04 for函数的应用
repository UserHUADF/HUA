//for函数的应用：
//计算阶乘的和  例如下列为计算1！+2！+3！
int main()
{

	int i=1;
	int n=0;
	int ret=1;
	int sum=0;
	for(n=1;n<=3;n++)
	{
		ret=ret*n;
		sum=sum+ret;
	}
	printf("%d\n",sum);
}

阶乘可以用ret*i(i是顺序变换的数字)表示
计算多个阶乘的和 用for循环解决


在一个有序数组中查找具体的某个数字n 编写int binsearch(int x,int v[],int n)
功能：在v[0]<=v[1]<=v[2]<=....<=v[n-1]的数组中查找x

注：此处有个元素个数计算公式sz
int sz=sizeof(arr)/sizeof(arr[0]);//元素个数

以下为在一个数组中中找到7这个数 并显示其下标
#include<stdio.h>

int main()
{
	int arr[]={1,2,3,4,5,6,7,8,9,10,};
	int k=7;
	//写一个代码 在arr数组中(有序)找到7
	int i=0;
	int sz=sizeof(arr)/sizeof(arr[0]); //这里是计算arr中元素个数
	for(i=0;i<sz;i++)
	{
		if(k == arr[i])  //这里是设置条件 即在arr中找到了7这个数
		{
		
			printf("找到了 下标是：%d\n",i);
			break;
		}
	}
	if(i == sz)  //此时i等于sz 此时已经不属于arr数组了 即找全了所有arr中的数字 均不满足等于7

		printf("找不到\n");
	return 0;
}
//这种方式查找起来最坏的情况需要n次

//折半查找算法
//二分查找算法
//折半即元素的初始与末元素下标之和的平均值即/2
int main()
{
	int arr[]={1,2,3,4,5,6,7,8,9};
	int k=7;
	int left=0;//左下标为0
	int sz=sizeof(arr)/sizeof(arr[0]);//元素总个数  比右下标多一
	int right=sz-1;//右下标 初始元素下标为0
	while(left<=right)//括号内为条件
	{
		int maid=(left+right)/2;
		if(arr[maid]>k)
		{
			right=maid-1;
		}
		if(arr[maid]<k)
		{
			left=maid+1;
		}
		else
		{
			printf("找到了，下标是%d\n",maid);
			break;
		}
	}
	if(left>right)
	{
		printf("找不到\n");
	}
}
二分法大大减小了大量数据的查找效率
